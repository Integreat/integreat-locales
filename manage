#!/usr/bin/node

const program = require('commander')
const fs = require('fs')
const path = require('path')
const flat = require('flat')
const {unflatten} = flat
const stringify = require('csv-stringify')
const parse = require('csv-parse/lib/sync')

const {isEmpty, without, isString, merge, fromPairs, toPairs, zip, sortBy, mapValues} = require('lodash')

program
  .version('0.1.0')
  .option('-d, --debug', 'enable extreme logging')
  .option('-c, --config <config_file>', 'set configuration for managing translations', 'config.json')

program
  .command('check <locales_file>')
  .action(function (localesFile, options) {
    console.log(localesFile)
  })

const mapStringValuesDeep = (obj, fn) =>
  mapValues(obj, (val, key) =>
    !isString(val)
      ? mapStringValuesDeep(val, fn)
      : fn(val, key, obj)
  )

const flattenModules = (modules) => {
  return flat(modules)
}

const writePairs = (sourceLanguagePairs, pairs, name) => {
  const output = fs.createWriteStream(`csv/${name}.csv`)

  output.on('close', () => {
    console.log(`Successfully written ${name}.csv.`)
  })

  output.on('error', () => {
    console.log(`Failed to write ${name}.csv.`)
  })

  const withSourceLanguagePairs = zip(sourceLanguagePairs, pairs)
    .map(([[sourceKey, sourceTranslation], [key, translation]]) => [key, sourceTranslation, translation])

  stringify(
    [
      ['key', 'source_language', 'target_language'],
      ...withSourceLanguagePairs
    ]
  ).pipe(output)
}

const EMPTY_MODULE = {}

/**
 * Create a a translation skeleton which has all keys set to an empty string
 *
 * @param language The language which serves as the skeleton
 * @param moduleArray The array of modules (containing all languages) with its keys
 * @returns {*}
 */
const createSkeleton = (language, moduleArray) => {
  return getModulesByLanguage(moduleArray, language)
    .map(([moduleKey, module]) => {

      if (module === EMPTY_MODULE) {
        throw new Error(`Module ${moduleKey} is missing in source language!`)
      }

      return [
        moduleKey,
        mapStringValuesDeep(module, translation => '')
      ]
    })
}

const getModulesByLanguage = (keyModuleArray, language) => {
  return keyModuleArray.map(([moduleKey, module]) => [moduleKey, (module[language] || EMPTY_MODULE)])
}

const mergeByLanguageModule = (byLanguageModule, skeleton, sourceLanguage) => {
  return zip(skeleton, byLanguageModule)
    .map(([[skModuleKey, skModule], [moduleKey, module]]) => {

      const diff = without(Object.keys(flat(module)), ...Object.keys(flat(skModule)))
      if (!isEmpty(diff)) {
        throw new Error(`The keys [${diff}] are missing in module ${moduleKey} 
                        (with the  source language ${sourceLanguage})!`)
      }

      return ([moduleKey, merge({}, skModule, module)])
    })
}

const writeCsvFromJson = (json, sourceLanguage, targetLanguages) => {
  const moduleArray = sortBy(toPairs(json), ([moduleKey, module]) => moduleKey)
  const byLanguageModuleArray = fromPairs(
    targetLanguages.map(targetLanguage => [targetLanguage, getModulesByLanguage(moduleArray, targetLanguage)])
  )

  const skeleton = createSkeleton(sourceLanguage, moduleArray)

  const filledByLanguageModuleArray = mapValues(
    byLanguageModuleArray,
    (byLanguageModule) => {
      return mergeByLanguageModule(byLanguageModule, skeleton, sourceLanguage)
    }
  )

  const flattenByLanguage = mapValues(
    filledByLanguageModuleArray,
    (modules) => flattenModules(fromPairs(modules))
  )

  const flattenSourceLanguage = flattenModules(fromPairs(getModulesByLanguage(moduleArray, sourceLanguage)))

  Object.entries(flattenByLanguage)
    .forEach(([languageKey, modules]) =>
      writePairs(toPairs(flattenSourceLanguage), toPairs(modules), languageKey))

  console.log(`Keys in source language ${sourceLanguage}: ${Object.keys(flattenSourceLanguage).length}`)
}

program
  .command('convert <locales_file> <format>')
  .action(function (locales, format, options) {
    const {targetLanguages, sourceLanguage} = JSON.parse(fs.readFileSync(program.config, 'utf8'))

    if (format === 'csv') {
      if (path.extname(locales) === '.json') {
        const json = JSON.parse(fs.readFileSync(locales, 'utf8'))
        writeCsvFromJson(json, sourceLanguage, targetLanguages)
      } else {
        throw new Error('nyi')
      }
    } else if (format === 'json') {
      fs.readdir(locales, (err, files) => {
        if (err) {
          throw err
        }

        const byLanguageModules = fromPairs(files.filter(file => path.extname(file) === '.csv').map(file => {
          const inputString = fs.readFileSync(`${locales}/${file}`, {encoding: 'utf8'}).trim() // .trim() is needed to strip the BOM
          const records = parse(inputString, {
            columns: true,
            skip_empty_lines: true
          })

          const flattened = fromPairs(records.map(record => [record['key'], record['target_language']]))

          const unflattened = unflatten(flattened)

          return [path.basename(file, '.csv'), unflattened]
        }))

        const languageKeys = Object.keys(byLanguageModules)
        const moduleKeys = Object.keys(byLanguageModules['en'])

        const out = fromPairs(moduleKeys.map(moduleKey => [
          moduleKey,
          fromPairs(languageKeys.map(languageKey => [
            languageKey,
            byLanguageModules[languageKey][moduleKey]]))])
        )
        out
      })
    }
  })

program.parse(process.argv)
