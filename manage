#!/usr/bin/node

const program = require('commander')
const fs = require('fs')
const path = require('path')
const flat = require('flat')
const stringify = require('csv-stringify')

const {isEmpty, without, isString, merge, fromPairs, toPairs, zip, sortBy, mapValues} = require('lodash')

program
  .version('0.1.0')
  .option('-d, --debug', 'enable extreme logging')
  .option('-c, --config <config_file>', 'set configuration for managing translations', 'config.json')

program
  .command('check <locales_file>')
  .action(function (localesFile, options) {
    console.log(localesFile)
  })

const mapStringValuesDeep = (obj, fn) =>
  mapValues(obj, (val, key) =>
    !isString(val)
      ? mapStringValuesDeep(val, fn)
      : fn(val, key, obj)
  )

const flattenModules = (modules) => {
  return flat(modules)
}

const writePairs = (sourceLanguagePairs, pairs, name) => {
  const output = fs.createWriteStream(`csv/${name}.csv`)

  output.on('close', () => {
    console.log(`Successfully written ${name}.csv.`)
  })

  output.on('error', () => {
    console.log(`Failed to write ${name}.csv.`)
  })

  const withSourceLanguagePairs = zip(sourceLanguagePairs, pairs)
    .map(([[sourceKey, sourceTranslation], [key, translation]]) => [key, sourceTranslation, translation])

  stringify(
    [
      ['key', 'source_language', 'target_language'],
      ...withSourceLanguagePairs
    ]
  ).pipe(output)
}

const EMPTY_MODULE = {}

/**
 * Create a a translation skeleton which has all keys set to an empty string
 *
 * @param language The language which serves as the skeleton
 * @param moduleArray The array of modules (containing all languages) with its keys
 * @returns {*}
 */
const createSkeleton = (language, moduleArray) => {
  return getModulesByLanguage(moduleArray, language)
    .map(([moduleKey, module]) => {

      if (module === EMPTY_MODULE) {
        throw new Error(`Module ${moduleKey} is missing in source language!`)
      }

      return [
        moduleKey,
        mapStringValuesDeep(module, translation => '')
      ]
    })
}

const getModulesByLanguage = (keyModuleArray, language) => {
  return keyModuleArray.map(([moduleKey, module]) => [moduleKey, (module[language] || EMPTY_MODULE)])
}

const mergeByLanguageModule = (byLanguageModule, skeleton, sourceLanguage) => {
  return zip(skeleton, byLanguageModule)
    .map(([[skModuleKey, skModule], [moduleKey, module]]) => {

      const diff = without(Object.keys(flat(module)), ...Object.keys(flat(skModule)))
      if (!isEmpty(diff)) {
        throw new Error(`The keys [${diff}] are missing in module ${moduleKey} 
                        (with the  source language ${sourceLanguage})!`)
      }

      return ([moduleKey, merge({}, skModule, module)])
    })
}

const writeCsvFromJson = (json, sourceLanguage, targetLanguages) => {
  const moduleArray = sortBy(toPairs(json), ([moduleKey, module]) => moduleKey)
  const byLanguageModuleArray = fromPairs(
    targetLanguages.map(targetLanguage => [targetLanguage, getModulesByLanguage(moduleArray, targetLanguage)])
  )

  const skeleton = createSkeleton(sourceLanguage, moduleArray)

  const filledByLanguageModuleArray = mapValues(
    byLanguageModuleArray,
    (byLanguageModule) => {
      return mergeByLanguageModule(byLanguageModule, skeleton, sourceLanguage)
    }
  )

  const flattenByLanguageModuleArray = mapValues(
    filledByLanguageModuleArray,
    (modules) => flattenModules(fromPairs(modules))
  )

  const flattenSourceLanguageModuleArray = flattenModules(fromPairs(getModulesByLanguage(moduleArray, sourceLanguage)))

  Object.entries(flattenByLanguageModuleArray)
    .forEach(([languageKey, modules]) =>
      writePairs(toPairs(flattenSourceLanguageModuleArray), toPairs(modules), languageKey))

  console.log(`Keys in source language ${sourceLanguage}: ${Object.keys(flattenSourceLanguageModuleArray).length}`)
}

program
  .command('convert <locales_file> <format>')
  .action(function (locales, format, options) {
    const {targetLanguages, sourceLanguage} = JSON.parse(fs.readFileSync(program.config, 'utf8'))

    if (format !== 'csv') {
      throw new Error('nyi')
    }

    if (path.extname(locales) === '.json') {
      const json = JSON.parse(fs.readFileSync(locales, 'utf8'))
      writeCsvFromJson(json, sourceLanguage, targetLanguages)
    } else {
      throw new Error('nyi')
    }
  })

program.parse(process.argv)
