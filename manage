#!/usr/bin/node

const program = require('commander')
const fs = require('fs')
const path = require('path')
const flat = require('flat')
const stringify = require('csv-stringify')

const {reduce, map, isEmpty, union, isString, merge, fromPairs, toPairs, zip, sortBy, mapValues, isPlainObject} = require('lodash')

function parseFormat (value) {
  if (!['csv', 'json'].includes(value)) {
    throw new Error('Format must be xml or json')
  }
  return value
}

program
  .version('0.1.0')
  .option('-d, --debug', 'enable extreme logging')
  .option('-c, --config <config_file>', 'set configuration for managing translations', 'config.json')

program
  .command('check <locales_file>')
  .action(function (localesFile, options) {
    console.log(localesFile)
  })

const getModulesByLanguage = (keyModuleArray, language) => {
  return keyModuleArray.map(([moduleKey, module]) => [moduleKey, (module[language] || {})])
}

function flatten (xs, childSelector) {
  return xs.reduce((acc, x) => {
    acc = acc.concat(x)
    let children = childSelector(x)
    if (children) {
      acc = acc.concat(flatten(children, childSelector))
    }
    return acc
  }, [])
}

const mapStringValuesDeep = (obj, fn) =>
  mapValues(obj, (val, key) =>
    !isString(val)
      ? mapStringValuesDeep(val, fn)
      : fn(val, key, obj)
  )

const flattenModules = (modules) => {
  return flat(modules)
}

const writePairs = (pairs, name) => {
  const output = fs.createWriteStream(`csv/${name}.csv`)

  output.on('close', () => {
    console.log(`Successfully written ${name}.csv.`)
  })

  output.on('error', () => {
    console.log(`Failed to write ${name}.csv.`)
  })

  stringify(
    pairs
  ).pipe(output)
}

program
  .command('convert <locales_file> <format>')
  .action(function (locales, format, options) {
    const {targetLanguages, sourceLanguage} = JSON.parse(fs.readFileSync(program.config, 'utf8'))

    if (path.extname(locales) === '.json') {
      const json = JSON.parse(fs.readFileSync(locales, 'utf8'))

      const keyModuleArray = sortBy(toPairs(json), ([moduleKey, module]) => moduleKey)

      const skeleton = getModulesByLanguage(keyModuleArray, sourceLanguage)
        .map(([moduleKey, module]) => {

          if (isEmpty(module)) {
            throw new Error(`Module ${moduleKey} is missing in source language!`)
          }

          return [
            moduleKey,
            mapStringValuesDeep(module, translation => '')
          ]
        })

      const perLanguageModules = fromPairs(
        targetLanguages.map(targetLanguage =>
          [targetLanguage, getModulesByLanguage(keyModuleArray, targetLanguage)]
        ))

      const filledPerLangaugeLocales = mapValues(perLanguageModules, (modules) => {
        return zip(skeleton, modules).map(([[skModuleKey, skModule], [moduleKey, module]]) => ([moduleKey, merge({}, skModule, module)]))
      })

      const flattenPerLanguageLocales = mapValues(filledPerLangaugeLocales, (modules) => flattenModules(fromPairs(modules)))

      Object.entries(flattenPerLanguageLocales).forEach(([languageKey, modules]) => writePairs(toPairs(modules).map(([key, string]) => ([key, string.replace(/[\u200E]/g, '\\u200E')])), languageKey))

    } else {
      throw new Error('nyi')
    }
  })

program.parse(process.argv)
